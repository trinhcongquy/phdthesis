%% =============================================================
\chapter*{Sammanfattning på Svenska \texorpdfstring{\hfill\raisebox{-2em}{\includegraphics[height=3em]{img/sverige.png}}}{}}
\addcontentsline{toc}{section}{\texorpdfstring{\protect\raisebox{-0.5ex}{\protect\makebox[3ex]{\protect\includegraphics[height=1em]{img/flag-sverige.png}}}}{} in Swedish}
\index{Summary!Sammanfattning \protect\makebox[3ex]{\protect\includegraphics[height=1em]{img/flag-sverige.png}}}

%Computers have been used for a variety of applications in business, science, education, engineering and so on. They help to solve real-world problems that would otherwise be slow, impossible or extremely difficult to address without computers and software. However, sometimes they do not behave exactly as we expect them. In many cases, the consequences could be very serious, for example when errors in banking or flight control software result in unexpected behaviours. Errors in computer systems are mostly not caused by the machine itself, but typically originate from the software that controls the computer systems, so-called bugs. Bugs are quite common in complex software systems since they typically have complicated input and involve many features, which makes them difficult to design and make them perfect by human effort. Detecting and fixing software bugs are important tasks in software development process. Remaining undetected bugs in any software project may lead huge problems. They can be very hard to detect and correct, especially if they are discovered after the software has been delivered. Therefore, it is very important to allocate sufficient resources, both in terms of time and manpower, to ensure that developed software is as free of bugs as possible. 
%
%Some bugs are less serious than others. Some types of software, e.g., in user interfaces or entertainment software, can be useable even if it contains a small number of bugs.
%However, in the case of critical systems and system components such as software in libraries of programming languages, 
%bugs can have far-reaching consequences, and must be avoided as much as possible.
%Some of libraries provide standard data structures such as stacks, queues, containers. Such data structures provide ways of storing  
%and retrieving data in a way that suits the application at hand.
%By using data structures data can be easily, and efficiently exchanged; it allows portability, comprehensibility, and adaptability of information.
%
%A data structure can be both sequential or concurrent which is tricky and difficult to get correct. Concurrent data structures can be accessed and manipulated concurrently by many parallel threads are a central component of many parallel software applications. A data structure should ideally provide a simple interface to the software that uses it. An interface provides the set of operations with specifications about their types of arguments and returned values. Data structures typically use heap-allocated memory to store their data. For example, the concurrent linked queue in java.util.concurrent uses a singly linked list to organize their data. The data structure may be quite complex like skiplists and binary trees which are used to implement sets.
%
%
%The predominant method to ensure software quality is
%\emph{testing}. It is a dynamic analysis where a program is executed under specific conditions, in so-called test cases, while checking whether the result for a given input matches the expected output. The test cases should be carefully designed to cover as many as possible cases of program executions.
%However, it is infeasible to cover all possible executions. Therefore, it is said by Edsger W. Dijkstra that testing can be used to show the presence of bugs, but never to show their absence.  It would be nice to have techniques for checking that all executions conform to the interface of a data structure.
%A possibility is to use formal techniques which is the approach used in this thesis. 
%Formal verification uses mathematical methods to check whether a program, or piece of software satisfies its specification. 
%There are several approaches to formal verification, including equivalence checking, theorem proving, and model checking. Equivalence checking method decides whether a system is equivalent to its specification with respect to some notion of equivalence. In industry, this is mostly used for hardware designs. Theorem proving is a technique where both the behavior of the system and its desired properties are expressed in mathematical logic. Then, theorem proving, typically assisted by an interactive theorem prover, will try to prove that the system satisfies these properties. Model checking takes as input a model of the program under consideration and a formal specification of the a property to be verified as inputs. The specification of a software component may consist of a number of such properties, each of which can be verified using model checking. 
%
%This doctoral thesis considers the proving both safety properties, and linearization properties of
%both sequential and concurrent heap manipulating programs.
%Such programs induce an infinite-state space in several dimensions:
%they %
%(i) consist of an unbounded number of concurrent threads, %
%(ii) use unbounded dynamically allocated memory, and %
%(iii) the domain of data values is unbounded. %
%(iv) consist of un unbounded number of pointers. 
%In addition, the linearization points of some programs are not fixed. They are depended on the future executions of these programs. 
%Our method is to define an abstract model of the program, and we employ approximation techniques to that ignore irrelevant information so that we can reduce the problem into a finite-state model. In fact, we use an over-approximation, such that the abstract model cover all the behaviors of the original system.  Our framework is the first that
%can automatically verify concurrent data structure implementations that employ
%singly linked lists, skiplists~\cite{Fomitchev:2004,ArtOfMpP,Sundell:2005},
%as well as arrays of singly linked lists~\cite{ts-stack},
%at the same time as handling an unbounded
%number of concurrent threads, an unbounded domain of data values
%(including timestamps), and an unbounded shared heap. To the best of our knowledge, these verification problems have been
%considered challenging in the verification community and
%could not be carried out automatically by other existing methods.


Datorer har använts för flera olika ändamål inom näringsliv, vetenskap, utbildning, teknik och så vidare. De hjälper till att lösa verkliga problem som annars skulle vara långsamma, omöjliga eller extremt svåra att lösa utan datorer och programvara. Ibland beter de sig dock inte exakt som vi förväntar oss. I många fall kan konsekvenserna bli mycket allvarliga, t.ex. när fel i bank- eller flygkontrollprogramvara leder till oväntade beteenden. Fel i datorsystem orsakas oftast inte av själva maskinen, utan har sitt ursprung i den programvara som styr datorsystemen, så kallade buggar. Buggar är ganska vanliga i komplexa programvarusystem eftersom de vanligtvis har komplicerad indata och många funktioner, vilket gör dem svåra att utforma och göra perfekta genom mänsklig ansträngning. Att upptäcka och åtgärda programvarubuggar är viktiga uppgifter i programvaruutvecklingsprocessen. Om buggar förblir oupptäckta i ett programvaruprojekt kan det leda till stora problem. De kan vara mycket svåra att upptäcka och korrigera, särskilt om de upptäcks efter att programvaran har levererats. Därför är det mycket viktigt att avsätta tillräckliga resurser, både i form av tid och arbetskraft, för att säkerställa att den utvecklade programvaran är så fri från buggar som möjligt.
Vissa buggar är mindre allvarliga än andra. Vissa typer av programvara, t.ex. i användargränssnitt eller underhållningsprogram, kan vara användbara även om de innehåller ett litet antal buggar. När det gäller kritiska system och systemkomponenter, t.ex. programvara i bibliotek med programmeringsspråk, kan buggar dock få långtgående konsekvenser och måste undvikas så mycket som möjligt. Vissa bibliotek tillhandahåller standardiserade datastrukturer som stackar, köer och containrar. Sådana datastrukturer gör det möjligt att lagra och hämta data på ett sätt som passar den aktuella applikationen. Genom att använda datastrukturer kan data enkelt och effektivt utbytas; det möjliggör portabilitet, begriplighet och anpassningsbarhet av information. 
En datastruktur kan vara både sekventiell eller samtidig, vilket är knepigt och svårt att få korrekt. Samtidiga datastrukturer kan nås och manipuleras samtidigt av många parallella trådar och är en central komponent i många parallella programvaruapplikationer. En datastruktur bör helst tillhandahålla ett enkelt gränssnitt för den programvara som använder den. Ett gränssnitt innehåller en uppsättning operationer med specifikationer om deras typer av argument och returvärden. Datastrukturer använder vanligtvis heap-allokerat minne för att lagra sina data. Till exempel använder concurrent linked queue i java.util.concurrent en singly linked list för att organisera sina data. Datastrukturen kan vara ganska komplex, som skiplists och binära träd som används för att implementera uppsättningar.
Den dominerande metoden för att säkerställa programvarukvalitet är testning. Det är en dynamisk analys där ett program körs under specifika förhållanden, i så kallade testfall, samtidigt som man kontrollerar om resultatet för en given indata matchar den förväntade utdata. Testfallen bör vara noggrant utformade för att täcka in så många fall som möjligt av programkörningar. Det är dock omöjligt att täcka in alla möjliga exekveringar. Därför säger Edsger W. Dijkstra att testning kan användas för att visa förekomsten av buggar, men aldrig för att visa deras frånvaro. Det skulle vara trevligt att ha tekniker för att kontrollera att alla exekveringar överensstämmer med en datastrukturs inter- face. En möjlighet är att använda formella tekniker, vilket är det tillvägagångssätt som används i denna avhandling. Formell verifiering använder matematiska metoder för att kontrollera om ett program eller en mjukvara uppfyller sin specifikation. Det finns flera tillvägagångssätt för formell verifiering, inklusive ekvivalenskontroll, teorembevis och modellkontroll. Ekvivalenskontroll avgör om ett system är ekvivalent med sin specifikation med avseende på något ekvivalensbegrepp. Inom industrin används detta främst för hårdvarukonstruktioner. Teorembevis är en teknik där både systemets beteende och dess önskade egenskaper uttrycks i matematisk logik. Därefter försöker teorembevisningen, vanligtvis med hjälp av en interaktiv teorembevisare, bevisa att systemet uppfyller dessa egenskaper. Vid modellkontroll används som indata en modell av det aktuella programmet och en formell specifikation av den egenskap som skall verifieras. Specifikationen av en programvarukomponent kan bestå av ett antal sådana egenskaper, av vilka var och en kan verifieras med hjälp av modellkontroll. 
Denna doktorsavhandling behandlar bevisningen av både säkerhetsegenskaper och linjäriseringsegenskaper för både sekventiella och samtidiga heap-manipulerande program. Sådana program inducerar ett oändligt tillståndsrum i flera dimensioner: de (i) består av ett obegränsat antal samtidiga trådar, (ii) använder obegränsat dynamiskt allokerat minne, och (iii) domänen av datavärden är obegränsad. (iv) består av ett obegränsat antal pekare. Dessutom är linjäriseringspunkterna för vissa program inte fasta. De är beroende av framtida exekveringar av dessa program. Vår metod är att definiera en abstrakt modell av programmet, och vi använder approximationstekniker som ignorerar irrelevant information så att vi kan reducera problemet till en finite-state-modell. I själva verket använder vi en överapproximation, så att den abstrakta modellen täcker alla beteenden i det ursprungliga systemet. Vårt ramverk är det första som automatiskt kan verifiera samtidiga implementeringar av datastrukturer som använder enkelt länkade listor, skiplists [57, 70, 117], samt matriser av enkelt länkade listor [47], samtidigt som de hanterar ett obegränsat antal samtidiga trådar, en obegränsad domän av datavärden (inklusive tidsstämplar) och en obegränsad delad heap. Såvitt vi vet har dessa verifieringsproblem ansetts vara utmanande inom verifieringssamhället och kunde inte utföras automatiskt med andra befintliga metoder.

